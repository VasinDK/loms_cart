// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/loms/internal/service.OrderRepo -o order_repo_mock.go -n OrderRepoMock -p mocks

import (
	"context"
	"route256/loms/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderRepoMock implements service.OrderRepo
type OrderRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(ctx context.Context, op1 *model.Order) (o1 model.OrderId, err error)
	inspectFuncAdd   func(ctx context.Context, op1 *model.Order)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mOrderRepoMockAdd

	funcGetById          func(ctx context.Context, o1 model.OrderId) (op1 *model.Order, err error)
	inspectFuncGetById   func(ctx context.Context, o1 model.OrderId)
	afterGetByIdCounter  uint64
	beforeGetByIdCounter uint64
	GetByIdMock          mOrderRepoMockGetById

	funcSetStatus          func(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) (err error)
	inspectFuncSetStatus   func(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderRepoMockSetStatus
}

// NewOrderRepoMock returns a mock for service.OrderRepo
func NewOrderRepoMock(t minimock.Tester) *OrderRepoMock {
	m := &OrderRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mOrderRepoMockAdd{mock: m}
	m.AddMock.callArgs = []*OrderRepoMockAddParams{}

	m.GetByIdMock = mOrderRepoMockGetById{mock: m}
	m.GetByIdMock.callArgs = []*OrderRepoMockGetByIdParams{}

	m.SetStatusMock = mOrderRepoMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderRepoMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepoMockAdd struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockAddExpectation
	expectations       []*OrderRepoMockAddExpectation

	callArgs []*OrderRepoMockAddParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockAddExpectation specifies expectation struct of the OrderRepo.Add
type OrderRepoMockAddExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockAddParams
	paramPtrs *OrderRepoMockAddParamPtrs
	results   *OrderRepoMockAddResults
	Counter   uint64
}

// OrderRepoMockAddParams contains parameters of the OrderRepo.Add
type OrderRepoMockAddParams struct {
	ctx context.Context
	op1 *model.Order
}

// OrderRepoMockAddParamPtrs contains pointers to parameters of the OrderRepo.Add
type OrderRepoMockAddParamPtrs struct {
	ctx *context.Context
	op1 **model.Order
}

// OrderRepoMockAddResults contains results of the OrderRepo.Add
type OrderRepoMockAddResults struct {
	o1  model.OrderId
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mOrderRepoMockAdd) Optional() *mOrderRepoMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for OrderRepo.Add
func (mmAdd *mOrderRepoMockAdd) Expect(ctx context.Context, op1 *model.Order) *mOrderRepoMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OrderRepoMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &OrderRepoMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("OrderRepoMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &OrderRepoMockAddParams{ctx, op1}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepo.Add
func (mmAdd *mOrderRepoMockAdd) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OrderRepoMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &OrderRepoMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("OrderRepoMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &OrderRepoMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAdd
}

// ExpectOp1Param2 sets up expected param op1 for OrderRepo.Add
func (mmAdd *mOrderRepoMockAdd) ExpectOp1Param2(op1 *model.Order) *mOrderRepoMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OrderRepoMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &OrderRepoMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("OrderRepoMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &OrderRepoMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.op1 = &op1

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the OrderRepo.Add
func (mmAdd *mOrderRepoMockAdd) Inspect(f func(ctx context.Context, op1 *model.Order)) *mOrderRepoMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by OrderRepo.Add
func (mmAdd *mOrderRepoMockAdd) Return(o1 model.OrderId, err error) *OrderRepoMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OrderRepoMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &OrderRepoMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &OrderRepoMockAddResults{o1, err}
	return mmAdd.mock
}

// Set uses given function f to mock the OrderRepo.Add method
func (mmAdd *mOrderRepoMockAdd) Set(f func(ctx context.Context, op1 *model.Order) (o1 model.OrderId, err error)) *OrderRepoMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the OrderRepo.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the OrderRepo.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the OrderRepo.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mOrderRepoMockAdd) When(ctx context.Context, op1 *model.Order) *OrderRepoMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("OrderRepoMock.Add mock is already set by Set")
	}

	expectation := &OrderRepoMockAddExpectation{
		mock:   mmAdd.mock,
		params: &OrderRepoMockAddParams{ctx, op1},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up OrderRepo.Add return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockAddExpectation) Then(o1 model.OrderId, err error) *OrderRepoMock {
	e.results = &OrderRepoMockAddResults{o1, err}
	return e.mock
}

// Times sets number of times OrderRepo.Add should be invoked
func (mmAdd *mOrderRepoMockAdd) Times(n uint64) *mOrderRepoMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of OrderRepoMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	return mmAdd
}

func (mmAdd *mOrderRepoMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements service.OrderRepo
func (mmAdd *OrderRepoMock) Add(ctx context.Context, op1 *model.Order) (o1 model.OrderId, err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, op1)
	}

	mm_params := OrderRepoMockAddParams{ctx, op1}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockAddParams{ctx, op1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAdd.t.Errorf("OrderRepoMock.Add got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.op1 != nil && !minimock.Equal(*mm_want_ptrs.op1, mm_got.op1) {
				mmAdd.t.Errorf("OrderRepoMock.Add got unexpected parameter op1, want: %#v, got: %#v%s\n", *mm_want_ptrs.op1, mm_got.op1, minimock.Diff(*mm_want_ptrs.op1, mm_got.op1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("OrderRepoMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the OrderRepoMock.Add")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, op1)
	}
	mmAdd.t.Fatalf("Unexpected call to OrderRepoMock.Add. %v %v", ctx, op1)
	return
}

// AddAfterCounter returns a count of finished OrderRepoMock.Add invocations
func (mmAdd *OrderRepoMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of OrderRepoMock.Add invocations
func (mmAdd *OrderRepoMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mOrderRepoMockAdd) Calls() []*OrderRepoMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*OrderRepoMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.Add with params: %#v", *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.Add")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.Add")
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.Add but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), afterAddCounter)
	}
}

type mOrderRepoMockGetById struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockGetByIdExpectation
	expectations       []*OrderRepoMockGetByIdExpectation

	callArgs []*OrderRepoMockGetByIdParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockGetByIdExpectation specifies expectation struct of the OrderRepo.GetById
type OrderRepoMockGetByIdExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockGetByIdParams
	paramPtrs *OrderRepoMockGetByIdParamPtrs
	results   *OrderRepoMockGetByIdResults
	Counter   uint64
}

// OrderRepoMockGetByIdParams contains parameters of the OrderRepo.GetById
type OrderRepoMockGetByIdParams struct {
	ctx context.Context
	o1  model.OrderId
}

// OrderRepoMockGetByIdParamPtrs contains pointers to parameters of the OrderRepo.GetById
type OrderRepoMockGetByIdParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderId
}

// OrderRepoMockGetByIdResults contains results of the OrderRepo.GetById
type OrderRepoMockGetByIdResults struct {
	op1 *model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetById *mOrderRepoMockGetById) Optional() *mOrderRepoMockGetById {
	mmGetById.optional = true
	return mmGetById
}

// Expect sets up expected params for OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) Expect(ctx context.Context, o1 model.OrderId) *mOrderRepoMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepoMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.paramPtrs != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by ExpectParams functions")
	}

	mmGetById.defaultExpectation.params = &OrderRepoMockGetByIdParams{ctx, o1}
	for _, e := range mmGetById.expectations {
		if minimock.Equal(e.params, mmGetById.defaultExpectation.params) {
			mmGetById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetById.defaultExpectation.params)
		}
	}

	return mmGetById
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepoMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &OrderRepoMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetById
}

// ExpectO1Param2 sets up expected param o1 for OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) ExpectO1Param2(o1 model.OrderId) *mOrderRepoMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepoMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &OrderRepoMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.o1 = &o1

	return mmGetById
}

// Inspect accepts an inspector function that has same arguments as the OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) Inspect(f func(ctx context.Context, o1 model.OrderId)) *mOrderRepoMockGetById {
	if mmGetById.mock.inspectFuncGetById != nil {
		mmGetById.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.GetById")
	}

	mmGetById.mock.inspectFuncGetById = f

	return mmGetById
}

// Return sets up results that will be returned by OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) Return(op1 *model.Order, err error) *OrderRepoMock {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepoMockGetByIdExpectation{mock: mmGetById.mock}
	}
	mmGetById.defaultExpectation.results = &OrderRepoMockGetByIdResults{op1, err}
	return mmGetById.mock
}

// Set uses given function f to mock the OrderRepo.GetById method
func (mmGetById *mOrderRepoMockGetById) Set(f func(ctx context.Context, o1 model.OrderId) (op1 *model.Order, err error)) *OrderRepoMock {
	if mmGetById.defaultExpectation != nil {
		mmGetById.mock.t.Fatalf("Default expectation is already set for the OrderRepo.GetById method")
	}

	if len(mmGetById.expectations) > 0 {
		mmGetById.mock.t.Fatalf("Some expectations are already set for the OrderRepo.GetById method")
	}

	mmGetById.mock.funcGetById = f
	return mmGetById.mock
}

// When sets expectation for the OrderRepo.GetById which will trigger the result defined by the following
// Then helper
func (mmGetById *mOrderRepoMockGetById) When(ctx context.Context, o1 model.OrderId) *OrderRepoMockGetByIdExpectation {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	expectation := &OrderRepoMockGetByIdExpectation{
		mock:   mmGetById.mock,
		params: &OrderRepoMockGetByIdParams{ctx, o1},
	}
	mmGetById.expectations = append(mmGetById.expectations, expectation)
	return expectation
}

// Then sets up OrderRepo.GetById return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockGetByIdExpectation) Then(op1 *model.Order, err error) *OrderRepoMock {
	e.results = &OrderRepoMockGetByIdResults{op1, err}
	return e.mock
}

// Times sets number of times OrderRepo.GetById should be invoked
func (mmGetById *mOrderRepoMockGetById) Times(n uint64) *mOrderRepoMockGetById {
	if n == 0 {
		mmGetById.mock.t.Fatalf("Times of OrderRepoMock.GetById mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetById.expectedInvocations, n)
	return mmGetById
}

func (mmGetById *mOrderRepoMockGetById) invocationsDone() bool {
	if len(mmGetById.expectations) == 0 && mmGetById.defaultExpectation == nil && mmGetById.mock.funcGetById == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetById.mock.afterGetByIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetById.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetById implements service.OrderRepo
func (mmGetById *OrderRepoMock) GetById(ctx context.Context, o1 model.OrderId) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmGetById.beforeGetByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetById.afterGetByIdCounter, 1)

	if mmGetById.inspectFuncGetById != nil {
		mmGetById.inspectFuncGetById(ctx, o1)
	}

	mm_params := OrderRepoMockGetByIdParams{ctx, o1}

	// Record call args
	mmGetById.GetByIdMock.mutex.Lock()
	mmGetById.GetByIdMock.callArgs = append(mmGetById.GetByIdMock.callArgs, &mm_params)
	mmGetById.GetByIdMock.mutex.Unlock()

	for _, e := range mmGetById.GetByIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetById.GetByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetById.GetByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetById.GetByIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetById.GetByIdMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockGetByIdParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetById.t.Errorf("OrderRepoMock.GetById got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmGetById.t.Errorf("OrderRepoMock.GetById got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetById.t.Errorf("OrderRepoMock.GetById got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetById.GetByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetById.t.Fatal("No results are set for the OrderRepoMock.GetById")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetById.funcGetById != nil {
		return mmGetById.funcGetById(ctx, o1)
	}
	mmGetById.t.Fatalf("Unexpected call to OrderRepoMock.GetById. %v %v", ctx, o1)
	return
}

// GetByIdAfterCounter returns a count of finished OrderRepoMock.GetById invocations
func (mmGetById *OrderRepoMock) GetByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.afterGetByIdCounter)
}

// GetByIdBeforeCounter returns a count of OrderRepoMock.GetById invocations
func (mmGetById *OrderRepoMock) GetByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.beforeGetByIdCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.GetById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetById *mOrderRepoMockGetById) Calls() []*OrderRepoMockGetByIdParams {
	mmGetById.mutex.RLock()

	argCopy := make([]*OrderRepoMockGetByIdParams, len(mmGetById.callArgs))
	copy(argCopy, mmGetById.callArgs)

	mmGetById.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIdDone returns true if the count of the GetById invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockGetByIdDone() bool {
	if m.GetByIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIdMock.invocationsDone()
}

// MinimockGetByIdInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockGetByIdInspect() {
	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.GetById with params: %#v", *e.params)
		}
	}

	afterGetByIdCounter := mm_atomic.LoadUint64(&m.afterGetByIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIdMock.defaultExpectation != nil && afterGetByIdCounter < 1 {
		if m.GetByIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.GetById")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.GetById with params: %#v", *m.GetByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetById != nil && afterGetByIdCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.GetById")
	}

	if !m.GetByIdMock.invocationsDone() && afterGetByIdCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.GetById but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIdMock.expectedInvocations), afterGetByIdCounter)
	}
}

type mOrderRepoMockSetStatus struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockSetStatusExpectation
	expectations       []*OrderRepoMockSetStatusExpectation

	callArgs []*OrderRepoMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockSetStatusExpectation specifies expectation struct of the OrderRepo.SetStatus
type OrderRepoMockSetStatusExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockSetStatusParams
	paramPtrs *OrderRepoMockSetStatusParamPtrs
	results   *OrderRepoMockSetStatusResults
	Counter   uint64
}

// OrderRepoMockSetStatusParams contains parameters of the OrderRepo.SetStatus
type OrderRepoMockSetStatusParams struct {
	ctx context.Context
	o1  model.OrderId
	o2  model.OrderStatus
}

// OrderRepoMockSetStatusParamPtrs contains pointers to parameters of the OrderRepo.SetStatus
type OrderRepoMockSetStatusParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderId
	o2  *model.OrderStatus
}

// OrderRepoMockSetStatusResults contains results of the OrderRepo.SetStatus
type OrderRepoMockSetStatusResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderRepoMockSetStatus) Optional() *mOrderRepoMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Expect(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderRepoMockSetStatusParams{ctx, o1, o2}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetStatus
}

// ExpectO1Param2 sets up expected param o1 for OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectO1Param2(o1 model.OrderId) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o1 = &o1

	return mmSetStatus
}

// ExpectO2Param3 sets up expected param o2 for OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectO2Param3(o2 model.OrderStatus) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o2 = &o2

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Inspect(f func(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus)) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Return(err error) *OrderRepoMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderRepoMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the OrderRepo.SetStatus method
func (mmSetStatus *mOrderRepoMockSetStatus) Set(f func(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) (err error)) *OrderRepoMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the OrderRepo.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the OrderRepo.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the OrderRepo.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderRepoMockSetStatus) When(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) *OrderRepoMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderRepoMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrderRepoMockSetStatusParams{ctx, o1, o2},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up OrderRepo.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockSetStatusExpectation) Then(err error) *OrderRepoMock {
	e.results = &OrderRepoMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times OrderRepo.SetStatus should be invoked
func (mmSetStatus *mOrderRepoMockSetStatus) Times(n uint64) *mOrderRepoMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderRepoMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	return mmSetStatus
}

func (mmSetStatus *mOrderRepoMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements service.OrderRepo
func (mmSetStatus *OrderRepoMock) SetStatus(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, o1, o2)
	}

	mm_params := OrderRepoMockSetStatusParams{ctx, o1, o2}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockSetStatusParams{ctx, o1, o2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.o2 != nil && !minimock.Equal(*mm_want_ptrs.o2, mm_got.o2) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter o2, want: %#v, got: %#v%s\n", *mm_want_ptrs.o2, mm_got.o2, minimock.Diff(*mm_want_ptrs.o2, mm_got.o2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderRepoMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, o1, o2)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderRepoMock.SetStatus. %v %v %v", ctx, o1, o2)
	return
}

// SetStatusAfterCounter returns a count of finished OrderRepoMock.SetStatus invocations
func (mmSetStatus *OrderRepoMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderRepoMock.SetStatus invocations
func (mmSetStatus *OrderRepoMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderRepoMockSetStatus) Calls() []*OrderRepoMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderRepoMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.SetStatus with params: %#v", *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.SetStatus")
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.SetStatus but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockGetByIdInspect()

			m.MinimockSetStatusInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockGetByIdDone() &&
		m.MinimockSetStatusDone()
}
