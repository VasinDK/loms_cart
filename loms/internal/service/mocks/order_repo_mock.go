// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/loms/internal/service.OrderRepo -o order_repo_mock.go -n OrderRepoMock -p mocks

import (
	"context"
	"route256/loms/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderRepoMock implements service.OrderRepo
type OrderRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, op1 *model.Order, o1 model.OrderId) (err error)
	inspectFuncAddItem   func(ctx context.Context, op1 *model.Order, o1 model.OrderId)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mOrderRepoMockAddItem

	funcAddOrder          func(ctx context.Context, op1 *model.Order) (o1 model.OrderId, err error)
	inspectFuncAddOrder   func(ctx context.Context, op1 *model.Order)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mOrderRepoMockAddOrder

	funcGetById          func(ctx context.Context, o1 model.OrderId) (op1 *model.Order, err error)
	inspectFuncGetById   func(ctx context.Context, o1 model.OrderId)
	afterGetByIdCounter  uint64
	beforeGetByIdCounter uint64
	GetByIdMock          mOrderRepoMockGetById

	funcOrderPay          func(ctx context.Context, o1 model.OrderId, op1 *model.Order) (err error)
	inspectFuncOrderPay   func(ctx context.Context, o1 model.OrderId, op1 *model.Order)
	afterOrderPayCounter  uint64
	beforeOrderPayCounter uint64
	OrderPayMock          mOrderRepoMockOrderPay

	funcSetStatus          func(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) (err error)
	inspectFuncSetStatus   func(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderRepoMockSetStatus
}

// NewOrderRepoMock returns a mock for service.OrderRepo
func NewOrderRepoMock(t minimock.Tester) *OrderRepoMock {
	m := &OrderRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mOrderRepoMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*OrderRepoMockAddItemParams{}

	m.AddOrderMock = mOrderRepoMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*OrderRepoMockAddOrderParams{}

	m.GetByIdMock = mOrderRepoMockGetById{mock: m}
	m.GetByIdMock.callArgs = []*OrderRepoMockGetByIdParams{}

	m.OrderPayMock = mOrderRepoMockOrderPay{mock: m}
	m.OrderPayMock.callArgs = []*OrderRepoMockOrderPayParams{}

	m.SetStatusMock = mOrderRepoMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderRepoMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepoMockAddItem struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockAddItemExpectation
	expectations       []*OrderRepoMockAddItemExpectation

	callArgs []*OrderRepoMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockAddItemExpectation specifies expectation struct of the OrderRepo.AddItem
type OrderRepoMockAddItemExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockAddItemParams
	paramPtrs *OrderRepoMockAddItemParamPtrs
	results   *OrderRepoMockAddItemResults
	Counter   uint64
}

// OrderRepoMockAddItemParams contains parameters of the OrderRepo.AddItem
type OrderRepoMockAddItemParams struct {
	ctx context.Context
	op1 *model.Order
	o1  model.OrderId
}

// OrderRepoMockAddItemParamPtrs contains pointers to parameters of the OrderRepo.AddItem
type OrderRepoMockAddItemParamPtrs struct {
	ctx *context.Context
	op1 **model.Order
	o1  *model.OrderId
}

// OrderRepoMockAddItemResults contains results of the OrderRepo.AddItem
type OrderRepoMockAddItemResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mOrderRepoMockAddItem) Optional() *mOrderRepoMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for OrderRepo.AddItem
func (mmAddItem *mOrderRepoMockAddItem) Expect(ctx context.Context, op1 *model.Order, o1 model.OrderId) *mOrderRepoMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &OrderRepoMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &OrderRepoMockAddItemParams{ctx, op1, o1}
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepo.AddItem
func (mmAddItem *mOrderRepoMockAddItem) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &OrderRepoMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &OrderRepoMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddItem
}

// ExpectOp1Param2 sets up expected param op1 for OrderRepo.AddItem
func (mmAddItem *mOrderRepoMockAddItem) ExpectOp1Param2(op1 *model.Order) *mOrderRepoMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &OrderRepoMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &OrderRepoMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.op1 = &op1

	return mmAddItem
}

// ExpectO1Param3 sets up expected param o1 for OrderRepo.AddItem
func (mmAddItem *mOrderRepoMockAddItem) ExpectO1Param3(o1 model.OrderId) *mOrderRepoMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &OrderRepoMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &OrderRepoMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.o1 = &o1

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the OrderRepo.AddItem
func (mmAddItem *mOrderRepoMockAddItem) Inspect(f func(ctx context.Context, op1 *model.Order, o1 model.OrderId)) *mOrderRepoMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by OrderRepo.AddItem
func (mmAddItem *mOrderRepoMockAddItem) Return(err error) *OrderRepoMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &OrderRepoMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &OrderRepoMockAddItemResults{err}
	return mmAddItem.mock
}

// Set uses given function f to mock the OrderRepo.AddItem method
func (mmAddItem *mOrderRepoMockAddItem) Set(f func(ctx context.Context, op1 *model.Order, o1 model.OrderId) (err error)) *OrderRepoMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the OrderRepo.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the OrderRepo.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	return mmAddItem.mock
}

// When sets expectation for the OrderRepo.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mOrderRepoMockAddItem) When(ctx context.Context, op1 *model.Order, o1 model.OrderId) *OrderRepoMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("OrderRepoMock.AddItem mock is already set by Set")
	}

	expectation := &OrderRepoMockAddItemExpectation{
		mock:   mmAddItem.mock,
		params: &OrderRepoMockAddItemParams{ctx, op1, o1},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up OrderRepo.AddItem return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockAddItemExpectation) Then(err error) *OrderRepoMock {
	e.results = &OrderRepoMockAddItemResults{err}
	return e.mock
}

// Times sets number of times OrderRepo.AddItem should be invoked
func (mmAddItem *mOrderRepoMockAddItem) Times(n uint64) *mOrderRepoMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of OrderRepoMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	return mmAddItem
}

func (mmAddItem *mOrderRepoMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements service.OrderRepo
func (mmAddItem *OrderRepoMock) AddItem(ctx context.Context, op1 *model.Order, o1 model.OrderId) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, op1, o1)
	}

	mm_params := OrderRepoMockAddItemParams{ctx, op1, o1}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockAddItemParams{ctx, op1, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("OrderRepoMock.AddItem got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.op1 != nil && !minimock.Equal(*mm_want_ptrs.op1, mm_got.op1) {
				mmAddItem.t.Errorf("OrderRepoMock.AddItem got unexpected parameter op1, want: %#v, got: %#v%s\n", *mm_want_ptrs.op1, mm_got.op1, minimock.Diff(*mm_want_ptrs.op1, mm_got.op1))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmAddItem.t.Errorf("OrderRepoMock.AddItem got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("OrderRepoMock.AddItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the OrderRepoMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, op1, o1)
	}
	mmAddItem.t.Fatalf("Unexpected call to OrderRepoMock.AddItem. %v %v %v", ctx, op1, o1)
	return
}

// AddItemAfterCounter returns a count of finished OrderRepoMock.AddItem invocations
func (mmAddItem *OrderRepoMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of OrderRepoMock.AddItem invocations
func (mmAddItem *OrderRepoMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mOrderRepoMockAddItem) Calls() []*OrderRepoMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*OrderRepoMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.AddItem with params: %#v", *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.AddItem")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.AddItem with params: %#v", *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.AddItem")
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.AddItem but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), afterAddItemCounter)
	}
}

type mOrderRepoMockAddOrder struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockAddOrderExpectation
	expectations       []*OrderRepoMockAddOrderExpectation

	callArgs []*OrderRepoMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockAddOrderExpectation specifies expectation struct of the OrderRepo.AddOrder
type OrderRepoMockAddOrderExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockAddOrderParams
	paramPtrs *OrderRepoMockAddOrderParamPtrs
	results   *OrderRepoMockAddOrderResults
	Counter   uint64
}

// OrderRepoMockAddOrderParams contains parameters of the OrderRepo.AddOrder
type OrderRepoMockAddOrderParams struct {
	ctx context.Context
	op1 *model.Order
}

// OrderRepoMockAddOrderParamPtrs contains pointers to parameters of the OrderRepo.AddOrder
type OrderRepoMockAddOrderParamPtrs struct {
	ctx *context.Context
	op1 **model.Order
}

// OrderRepoMockAddOrderResults contains results of the OrderRepo.AddOrder
type OrderRepoMockAddOrderResults struct {
	o1  model.OrderId
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mOrderRepoMockAddOrder) Optional() *mOrderRepoMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for OrderRepo.AddOrder
func (mmAddOrder *mOrderRepoMockAddOrder) Expect(ctx context.Context, op1 *model.Order) *mOrderRepoMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepoMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &OrderRepoMockAddOrderParams{ctx, op1}
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepo.AddOrder
func (mmAddOrder *mOrderRepoMockAddOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepoMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderRepoMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddOrder
}

// ExpectOp1Param2 sets up expected param op1 for OrderRepo.AddOrder
func (mmAddOrder *mOrderRepoMockAddOrder) ExpectOp1Param2(op1 *model.Order) *mOrderRepoMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepoMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderRepoMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.op1 = &op1

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepo.AddOrder
func (mmAddOrder *mOrderRepoMockAddOrder) Inspect(f func(ctx context.Context, op1 *model.Order)) *mOrderRepoMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by OrderRepo.AddOrder
func (mmAddOrder *mOrderRepoMockAddOrder) Return(o1 model.OrderId, err error) *OrderRepoMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepoMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &OrderRepoMockAddOrderResults{o1, err}
	return mmAddOrder.mock
}

// Set uses given function f to mock the OrderRepo.AddOrder method
func (mmAddOrder *mOrderRepoMockAddOrder) Set(f func(ctx context.Context, op1 *model.Order) (o1 model.OrderId, err error)) *OrderRepoMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepo.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepo.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	return mmAddOrder.mock
}

// When sets expectation for the OrderRepo.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mOrderRepoMockAddOrder) When(ctx context.Context, op1 *model.Order) *OrderRepoMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoMock.AddOrder mock is already set by Set")
	}

	expectation := &OrderRepoMockAddOrderExpectation{
		mock:   mmAddOrder.mock,
		params: &OrderRepoMockAddOrderParams{ctx, op1},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepo.AddOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockAddOrderExpectation) Then(o1 model.OrderId, err error) *OrderRepoMock {
	e.results = &OrderRepoMockAddOrderResults{o1, err}
	return e.mock
}

// Times sets number of times OrderRepo.AddOrder should be invoked
func (mmAddOrder *mOrderRepoMockAddOrder) Times(n uint64) *mOrderRepoMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of OrderRepoMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	return mmAddOrder
}

func (mmAddOrder *mOrderRepoMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements service.OrderRepo
func (mmAddOrder *OrderRepoMock) AddOrder(ctx context.Context, op1 *model.Order) (o1 model.OrderId, err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(ctx, op1)
	}

	mm_params := OrderRepoMockAddOrderParams{ctx, op1}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockAddOrderParams{ctx, op1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrder.t.Errorf("OrderRepoMock.AddOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.op1 != nil && !minimock.Equal(*mm_want_ptrs.op1, mm_got.op1) {
				mmAddOrder.t.Errorf("OrderRepoMock.AddOrder got unexpected parameter op1, want: %#v, got: %#v%s\n", *mm_want_ptrs.op1, mm_got.op1, minimock.Diff(*mm_want_ptrs.op1, mm_got.op1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("OrderRepoMock.AddOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the OrderRepoMock.AddOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(ctx, op1)
	}
	mmAddOrder.t.Fatalf("Unexpected call to OrderRepoMock.AddOrder. %v %v", ctx, op1)
	return
}

// AddOrderAfterCounter returns a count of finished OrderRepoMock.AddOrder invocations
func (mmAddOrder *OrderRepoMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of OrderRepoMock.AddOrder invocations
func (mmAddOrder *OrderRepoMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mOrderRepoMockAddOrder) Calls() []*OrderRepoMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*OrderRepoMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.AddOrder with params: %#v", *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.AddOrder")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.AddOrder with params: %#v", *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.AddOrder")
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.AddOrder but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), afterAddOrderCounter)
	}
}

type mOrderRepoMockGetById struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockGetByIdExpectation
	expectations       []*OrderRepoMockGetByIdExpectation

	callArgs []*OrderRepoMockGetByIdParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockGetByIdExpectation specifies expectation struct of the OrderRepo.GetById
type OrderRepoMockGetByIdExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockGetByIdParams
	paramPtrs *OrderRepoMockGetByIdParamPtrs
	results   *OrderRepoMockGetByIdResults
	Counter   uint64
}

// OrderRepoMockGetByIdParams contains parameters of the OrderRepo.GetById
type OrderRepoMockGetByIdParams struct {
	ctx context.Context
	o1  model.OrderId
}

// OrderRepoMockGetByIdParamPtrs contains pointers to parameters of the OrderRepo.GetById
type OrderRepoMockGetByIdParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderId
}

// OrderRepoMockGetByIdResults contains results of the OrderRepo.GetById
type OrderRepoMockGetByIdResults struct {
	op1 *model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetById *mOrderRepoMockGetById) Optional() *mOrderRepoMockGetById {
	mmGetById.optional = true
	return mmGetById
}

// Expect sets up expected params for OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) Expect(ctx context.Context, o1 model.OrderId) *mOrderRepoMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepoMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.paramPtrs != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by ExpectParams functions")
	}

	mmGetById.defaultExpectation.params = &OrderRepoMockGetByIdParams{ctx, o1}
	for _, e := range mmGetById.expectations {
		if minimock.Equal(e.params, mmGetById.defaultExpectation.params) {
			mmGetById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetById.defaultExpectation.params)
		}
	}

	return mmGetById
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepoMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &OrderRepoMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetById
}

// ExpectO1Param2 sets up expected param o1 for OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) ExpectO1Param2(o1 model.OrderId) *mOrderRepoMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepoMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &OrderRepoMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.o1 = &o1

	return mmGetById
}

// Inspect accepts an inspector function that has same arguments as the OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) Inspect(f func(ctx context.Context, o1 model.OrderId)) *mOrderRepoMockGetById {
	if mmGetById.mock.inspectFuncGetById != nil {
		mmGetById.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.GetById")
	}

	mmGetById.mock.inspectFuncGetById = f

	return mmGetById
}

// Return sets up results that will be returned by OrderRepo.GetById
func (mmGetById *mOrderRepoMockGetById) Return(op1 *model.Order, err error) *OrderRepoMock {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepoMockGetByIdExpectation{mock: mmGetById.mock}
	}
	mmGetById.defaultExpectation.results = &OrderRepoMockGetByIdResults{op1, err}
	return mmGetById.mock
}

// Set uses given function f to mock the OrderRepo.GetById method
func (mmGetById *mOrderRepoMockGetById) Set(f func(ctx context.Context, o1 model.OrderId) (op1 *model.Order, err error)) *OrderRepoMock {
	if mmGetById.defaultExpectation != nil {
		mmGetById.mock.t.Fatalf("Default expectation is already set for the OrderRepo.GetById method")
	}

	if len(mmGetById.expectations) > 0 {
		mmGetById.mock.t.Fatalf("Some expectations are already set for the OrderRepo.GetById method")
	}

	mmGetById.mock.funcGetById = f
	return mmGetById.mock
}

// When sets expectation for the OrderRepo.GetById which will trigger the result defined by the following
// Then helper
func (mmGetById *mOrderRepoMockGetById) When(ctx context.Context, o1 model.OrderId) *OrderRepoMockGetByIdExpectation {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepoMock.GetById mock is already set by Set")
	}

	expectation := &OrderRepoMockGetByIdExpectation{
		mock:   mmGetById.mock,
		params: &OrderRepoMockGetByIdParams{ctx, o1},
	}
	mmGetById.expectations = append(mmGetById.expectations, expectation)
	return expectation
}

// Then sets up OrderRepo.GetById return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockGetByIdExpectation) Then(op1 *model.Order, err error) *OrderRepoMock {
	e.results = &OrderRepoMockGetByIdResults{op1, err}
	return e.mock
}

// Times sets number of times OrderRepo.GetById should be invoked
func (mmGetById *mOrderRepoMockGetById) Times(n uint64) *mOrderRepoMockGetById {
	if n == 0 {
		mmGetById.mock.t.Fatalf("Times of OrderRepoMock.GetById mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetById.expectedInvocations, n)
	return mmGetById
}

func (mmGetById *mOrderRepoMockGetById) invocationsDone() bool {
	if len(mmGetById.expectations) == 0 && mmGetById.defaultExpectation == nil && mmGetById.mock.funcGetById == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetById.mock.afterGetByIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetById.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetById implements service.OrderRepo
func (mmGetById *OrderRepoMock) GetById(ctx context.Context, o1 model.OrderId) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmGetById.beforeGetByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetById.afterGetByIdCounter, 1)

	if mmGetById.inspectFuncGetById != nil {
		mmGetById.inspectFuncGetById(ctx, o1)
	}

	mm_params := OrderRepoMockGetByIdParams{ctx, o1}

	// Record call args
	mmGetById.GetByIdMock.mutex.Lock()
	mmGetById.GetByIdMock.callArgs = append(mmGetById.GetByIdMock.callArgs, &mm_params)
	mmGetById.GetByIdMock.mutex.Unlock()

	for _, e := range mmGetById.GetByIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetById.GetByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetById.GetByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetById.GetByIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetById.GetByIdMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockGetByIdParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetById.t.Errorf("OrderRepoMock.GetById got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmGetById.t.Errorf("OrderRepoMock.GetById got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetById.t.Errorf("OrderRepoMock.GetById got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetById.GetByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetById.t.Fatal("No results are set for the OrderRepoMock.GetById")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetById.funcGetById != nil {
		return mmGetById.funcGetById(ctx, o1)
	}
	mmGetById.t.Fatalf("Unexpected call to OrderRepoMock.GetById. %v %v", ctx, o1)
	return
}

// GetByIdAfterCounter returns a count of finished OrderRepoMock.GetById invocations
func (mmGetById *OrderRepoMock) GetByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.afterGetByIdCounter)
}

// GetByIdBeforeCounter returns a count of OrderRepoMock.GetById invocations
func (mmGetById *OrderRepoMock) GetByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.beforeGetByIdCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.GetById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetById *mOrderRepoMockGetById) Calls() []*OrderRepoMockGetByIdParams {
	mmGetById.mutex.RLock()

	argCopy := make([]*OrderRepoMockGetByIdParams, len(mmGetById.callArgs))
	copy(argCopy, mmGetById.callArgs)

	mmGetById.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIdDone returns true if the count of the GetById invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockGetByIdDone() bool {
	if m.GetByIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIdMock.invocationsDone()
}

// MinimockGetByIdInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockGetByIdInspect() {
	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.GetById with params: %#v", *e.params)
		}
	}

	afterGetByIdCounter := mm_atomic.LoadUint64(&m.afterGetByIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIdMock.defaultExpectation != nil && afterGetByIdCounter < 1 {
		if m.GetByIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.GetById")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.GetById with params: %#v", *m.GetByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetById != nil && afterGetByIdCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.GetById")
	}

	if !m.GetByIdMock.invocationsDone() && afterGetByIdCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.GetById but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIdMock.expectedInvocations), afterGetByIdCounter)
	}
}

type mOrderRepoMockOrderPay struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockOrderPayExpectation
	expectations       []*OrderRepoMockOrderPayExpectation

	callArgs []*OrderRepoMockOrderPayParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockOrderPayExpectation specifies expectation struct of the OrderRepo.OrderPay
type OrderRepoMockOrderPayExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockOrderPayParams
	paramPtrs *OrderRepoMockOrderPayParamPtrs
	results   *OrderRepoMockOrderPayResults
	Counter   uint64
}

// OrderRepoMockOrderPayParams contains parameters of the OrderRepo.OrderPay
type OrderRepoMockOrderPayParams struct {
	ctx context.Context
	o1  model.OrderId
	op1 *model.Order
}

// OrderRepoMockOrderPayParamPtrs contains pointers to parameters of the OrderRepo.OrderPay
type OrderRepoMockOrderPayParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderId
	op1 **model.Order
}

// OrderRepoMockOrderPayResults contains results of the OrderRepo.OrderPay
type OrderRepoMockOrderPayResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderPay *mOrderRepoMockOrderPay) Optional() *mOrderRepoMockOrderPay {
	mmOrderPay.optional = true
	return mmOrderPay
}

// Expect sets up expected params for OrderRepo.OrderPay
func (mmOrderPay *mOrderRepoMockOrderPay) Expect(ctx context.Context, o1 model.OrderId, op1 *model.Order) *mOrderRepoMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &OrderRepoMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.paramPtrs != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by ExpectParams functions")
	}

	mmOrderPay.defaultExpectation.params = &OrderRepoMockOrderPayParams{ctx, o1, op1}
	for _, e := range mmOrderPay.expectations {
		if minimock.Equal(e.params, mmOrderPay.defaultExpectation.params) {
			mmOrderPay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderPay.defaultExpectation.params)
		}
	}

	return mmOrderPay
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepo.OrderPay
func (mmOrderPay *mOrderRepoMockOrderPay) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &OrderRepoMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &OrderRepoMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrderPay
}

// ExpectO1Param2 sets up expected param o1 for OrderRepo.OrderPay
func (mmOrderPay *mOrderRepoMockOrderPay) ExpectO1Param2(o1 model.OrderId) *mOrderRepoMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &OrderRepoMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &OrderRepoMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.o1 = &o1

	return mmOrderPay
}

// ExpectOp1Param3 sets up expected param op1 for OrderRepo.OrderPay
func (mmOrderPay *mOrderRepoMockOrderPay) ExpectOp1Param3(op1 *model.Order) *mOrderRepoMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &OrderRepoMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &OrderRepoMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.op1 = &op1

	return mmOrderPay
}

// Inspect accepts an inspector function that has same arguments as the OrderRepo.OrderPay
func (mmOrderPay *mOrderRepoMockOrderPay) Inspect(f func(ctx context.Context, o1 model.OrderId, op1 *model.Order)) *mOrderRepoMockOrderPay {
	if mmOrderPay.mock.inspectFuncOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.OrderPay")
	}

	mmOrderPay.mock.inspectFuncOrderPay = f

	return mmOrderPay
}

// Return sets up results that will be returned by OrderRepo.OrderPay
func (mmOrderPay *mOrderRepoMockOrderPay) Return(err error) *OrderRepoMock {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &OrderRepoMockOrderPayExpectation{mock: mmOrderPay.mock}
	}
	mmOrderPay.defaultExpectation.results = &OrderRepoMockOrderPayResults{err}
	return mmOrderPay.mock
}

// Set uses given function f to mock the OrderRepo.OrderPay method
func (mmOrderPay *mOrderRepoMockOrderPay) Set(f func(ctx context.Context, o1 model.OrderId, op1 *model.Order) (err error)) *OrderRepoMock {
	if mmOrderPay.defaultExpectation != nil {
		mmOrderPay.mock.t.Fatalf("Default expectation is already set for the OrderRepo.OrderPay method")
	}

	if len(mmOrderPay.expectations) > 0 {
		mmOrderPay.mock.t.Fatalf("Some expectations are already set for the OrderRepo.OrderPay method")
	}

	mmOrderPay.mock.funcOrderPay = f
	return mmOrderPay.mock
}

// When sets expectation for the OrderRepo.OrderPay which will trigger the result defined by the following
// Then helper
func (mmOrderPay *mOrderRepoMockOrderPay) When(ctx context.Context, o1 model.OrderId, op1 *model.Order) *OrderRepoMockOrderPayExpectation {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepoMock.OrderPay mock is already set by Set")
	}

	expectation := &OrderRepoMockOrderPayExpectation{
		mock:   mmOrderPay.mock,
		params: &OrderRepoMockOrderPayParams{ctx, o1, op1},
	}
	mmOrderPay.expectations = append(mmOrderPay.expectations, expectation)
	return expectation
}

// Then sets up OrderRepo.OrderPay return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockOrderPayExpectation) Then(err error) *OrderRepoMock {
	e.results = &OrderRepoMockOrderPayResults{err}
	return e.mock
}

// Times sets number of times OrderRepo.OrderPay should be invoked
func (mmOrderPay *mOrderRepoMockOrderPay) Times(n uint64) *mOrderRepoMockOrderPay {
	if n == 0 {
		mmOrderPay.mock.t.Fatalf("Times of OrderRepoMock.OrderPay mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderPay.expectedInvocations, n)
	return mmOrderPay
}

func (mmOrderPay *mOrderRepoMockOrderPay) invocationsDone() bool {
	if len(mmOrderPay.expectations) == 0 && mmOrderPay.defaultExpectation == nil && mmOrderPay.mock.funcOrderPay == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderPay.mock.afterOrderPayCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderPay.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderPay implements service.OrderRepo
func (mmOrderPay *OrderRepoMock) OrderPay(ctx context.Context, o1 model.OrderId, op1 *model.Order) (err error) {
	mm_atomic.AddUint64(&mmOrderPay.beforeOrderPayCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderPay.afterOrderPayCounter, 1)

	if mmOrderPay.inspectFuncOrderPay != nil {
		mmOrderPay.inspectFuncOrderPay(ctx, o1, op1)
	}

	mm_params := OrderRepoMockOrderPayParams{ctx, o1, op1}

	// Record call args
	mmOrderPay.OrderPayMock.mutex.Lock()
	mmOrderPay.OrderPayMock.callArgs = append(mmOrderPay.OrderPayMock.callArgs, &mm_params)
	mmOrderPay.OrderPayMock.mutex.Unlock()

	for _, e := range mmOrderPay.OrderPayMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderPay.OrderPayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderPay.OrderPayMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderPay.OrderPayMock.defaultExpectation.params
		mm_want_ptrs := mmOrderPay.OrderPayMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockOrderPayParams{ctx, o1, op1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderPay.t.Errorf("OrderRepoMock.OrderPay got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmOrderPay.t.Errorf("OrderRepoMock.OrderPay got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.op1 != nil && !minimock.Equal(*mm_want_ptrs.op1, mm_got.op1) {
				mmOrderPay.t.Errorf("OrderRepoMock.OrderPay got unexpected parameter op1, want: %#v, got: %#v%s\n", *mm_want_ptrs.op1, mm_got.op1, minimock.Diff(*mm_want_ptrs.op1, mm_got.op1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderPay.t.Errorf("OrderRepoMock.OrderPay got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderPay.OrderPayMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderPay.t.Fatal("No results are set for the OrderRepoMock.OrderPay")
		}
		return (*mm_results).err
	}
	if mmOrderPay.funcOrderPay != nil {
		return mmOrderPay.funcOrderPay(ctx, o1, op1)
	}
	mmOrderPay.t.Fatalf("Unexpected call to OrderRepoMock.OrderPay. %v %v %v", ctx, o1, op1)
	return
}

// OrderPayAfterCounter returns a count of finished OrderRepoMock.OrderPay invocations
func (mmOrderPay *OrderRepoMock) OrderPayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.afterOrderPayCounter)
}

// OrderPayBeforeCounter returns a count of OrderRepoMock.OrderPay invocations
func (mmOrderPay *OrderRepoMock) OrderPayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.beforeOrderPayCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.OrderPay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderPay *mOrderRepoMockOrderPay) Calls() []*OrderRepoMockOrderPayParams {
	mmOrderPay.mutex.RLock()

	argCopy := make([]*OrderRepoMockOrderPayParams, len(mmOrderPay.callArgs))
	copy(argCopy, mmOrderPay.callArgs)

	mmOrderPay.mutex.RUnlock()

	return argCopy
}

// MinimockOrderPayDone returns true if the count of the OrderPay invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockOrderPayDone() bool {
	if m.OrderPayMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderPayMock.invocationsDone()
}

// MinimockOrderPayInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockOrderPayInspect() {
	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.OrderPay with params: %#v", *e.params)
		}
	}

	afterOrderPayCounter := mm_atomic.LoadUint64(&m.afterOrderPayCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayMock.defaultExpectation != nil && afterOrderPayCounter < 1 {
		if m.OrderPayMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.OrderPay")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.OrderPay with params: %#v", *m.OrderPayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPay != nil && afterOrderPayCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.OrderPay")
	}

	if !m.OrderPayMock.invocationsDone() && afterOrderPayCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.OrderPay but found %d calls",
			mm_atomic.LoadUint64(&m.OrderPayMock.expectedInvocations), afterOrderPayCounter)
	}
}

type mOrderRepoMockSetStatus struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockSetStatusExpectation
	expectations       []*OrderRepoMockSetStatusExpectation

	callArgs []*OrderRepoMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockSetStatusExpectation specifies expectation struct of the OrderRepo.SetStatus
type OrderRepoMockSetStatusExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockSetStatusParams
	paramPtrs *OrderRepoMockSetStatusParamPtrs
	results   *OrderRepoMockSetStatusResults
	Counter   uint64
}

// OrderRepoMockSetStatusParams contains parameters of the OrderRepo.SetStatus
type OrderRepoMockSetStatusParams struct {
	ctx context.Context
	o1  model.OrderId
	o2  model.OrderStatus
}

// OrderRepoMockSetStatusParamPtrs contains pointers to parameters of the OrderRepo.SetStatus
type OrderRepoMockSetStatusParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderId
	o2  *model.OrderStatus
}

// OrderRepoMockSetStatusResults contains results of the OrderRepo.SetStatus
type OrderRepoMockSetStatusResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderRepoMockSetStatus) Optional() *mOrderRepoMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Expect(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderRepoMockSetStatusParams{ctx, o1, o2}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetStatus
}

// ExpectO1Param2 sets up expected param o1 for OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectO1Param2(o1 model.OrderId) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o1 = &o1

	return mmSetStatus
}

// ExpectO2Param3 sets up expected param o2 for OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectO2Param3(o2 model.OrderStatus) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o2 = &o2

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Inspect(f func(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus)) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by OrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Return(err error) *OrderRepoMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderRepoMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the OrderRepo.SetStatus method
func (mmSetStatus *mOrderRepoMockSetStatus) Set(f func(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) (err error)) *OrderRepoMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the OrderRepo.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the OrderRepo.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the OrderRepo.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderRepoMockSetStatus) When(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) *OrderRepoMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderRepoMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrderRepoMockSetStatusParams{ctx, o1, o2},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up OrderRepo.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockSetStatusExpectation) Then(err error) *OrderRepoMock {
	e.results = &OrderRepoMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times OrderRepo.SetStatus should be invoked
func (mmSetStatus *mOrderRepoMockSetStatus) Times(n uint64) *mOrderRepoMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderRepoMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	return mmSetStatus
}

func (mmSetStatus *mOrderRepoMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements service.OrderRepo
func (mmSetStatus *OrderRepoMock) SetStatus(ctx context.Context, o1 model.OrderId, o2 model.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, o1, o2)
	}

	mm_params := OrderRepoMockSetStatusParams{ctx, o1, o2}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockSetStatusParams{ctx, o1, o2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.o2 != nil && !minimock.Equal(*mm_want_ptrs.o2, mm_got.o2) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter o2, want: %#v, got: %#v%s\n", *mm_want_ptrs.o2, mm_got.o2, minimock.Diff(*mm_want_ptrs.o2, mm_got.o2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderRepoMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, o1, o2)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderRepoMock.SetStatus. %v %v %v", ctx, o1, o2)
	return
}

// SetStatusAfterCounter returns a count of finished OrderRepoMock.SetStatus invocations
func (mmSetStatus *OrderRepoMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderRepoMock.SetStatus invocations
func (mmSetStatus *OrderRepoMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderRepoMockSetStatus) Calls() []*OrderRepoMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderRepoMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.SetStatus with params: %#v", *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.SetStatus")
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.SetStatus but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockAddOrderInspect()

			m.MinimockGetByIdInspect()

			m.MinimockOrderPayInspect()

			m.MinimockSetStatusInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockAddOrderDone() &&
		m.MinimockGetByIdDone() &&
		m.MinimockOrderPayDone() &&
		m.MinimockSetStatusDone()
}
